# -*- coding: utf-8 -*-
"""recfinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xojA76ZkQ8BfW4m2UhwVo9af9DhjEPIN
"""

import pandas as pd
from surprise import Dataset, Reader, SVD
from surprise.dump import dump
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
import os

df = pd.read_csv("orders1.csv")

df.columns

df.drop("Unnamed: 0", axis=1, inplace=True)

df.head()

df.tail()

user_counts = df['id_utilisateur'].value_counts()
user_counts


from surprise import SVD
from surprise import Dataset, Reader
from surprise.model_selection import train_test_split
import ipywidgets as widgets
from IPython.display import display

print("Imports successful")
reader = Reader(rating_scale=(1, 5))
data = Dataset.load_from_df(df[['id_utilisateur', 'id_nett', 'note']], reader)

# Diviser les données en ensemble d'entraînement et ensemble de test
trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

# Entraîner le modèle SVD
model = SVD()
model.fit(trainset)

# Obtenir tous les types de nettoyage dans le DataFrame
types_nettoyage = df['type_nettoyage'].unique()

# Obtenir toutes les villes dans le DataFrame
villes = df['ville'].unique()

# Créer un widget interactif pour saisir le type de nettoyage
type_nettoyage_widget = widgets.Dropdown(
    options=types_nettoyage,
    value=types_nettoyage[0],
    description='Type de Nettoyage:',
    disabled=False,
)

# Créer un widget interactif pour saisir le type choisi
type_choisi_widget = widgets.Text(
    value='',
    placeholder='Saisissez le type choisi',
    description='Type Choisi:',
    disabled=False
)

# Créer un widget interactif pour saisir la ville
ville_widget = widgets.Dropdown(
    options=villes,
    value=villes[0],
    description='Ville:',
    disabled=False,
)

# Créer un bouton de recherche
recherche_button = widgets.Button(description="Rechercher")


# Définir une fonction pour gérer l'événement lorsque le bouton est cliqué
def on_button_click(b):
    type_nettoyage_choisi = type_nettoyage_widget.value
    type_choisi = type_choisi_widget.value
    ville_choisie = ville_widget.value

    # Attendre que le type choisi ne soit pas vide
    if type_choisi:
        # Filtrer le DataFrame en fonction du type de nettoyage, du type choisi et de la ville
        filtered_df = df[(df['type_nettoyage'] == type_nettoyage_choisi) &
                          (df['type'] == type_choisi) &
                          (df['ville'] == ville_choisie)]

        # Si aucune recommandation n'est disponible, afficher les 5 meilleurs nettoyeurs basés sur l'ensemble de données
        if filtered_df.empty:
            top_nettoyeurs_df = df.nlargest(5, 'note')
            print(f"Aucune recommandation n'est disponible. Affichage des 5 meilleurs nettoyeurs globaux:")
            for i, (id_nett, score) in enumerate(zip(top_nettoyeurs_df['id_nett'], top_nettoyeurs_df['note']), 1):
                print(f"{i}. Nettoyeur ID: {id_nett}, Note: {score}")
        else:
            # Obtenir les nettoyeurs pour le type de nettoyage, le type choisi et la ville
            nettoyeurs = filtered_df['id_nett'].unique()

            # Prédire les notes pour chaque nettoyeur dans la liste
            predictions = [(iid, model.predict(1, iid).est) for iid in nettoyeurs]

            # Trier les prédictions par note décroissante
            sorted_predictions = sorted(predictions, key=lambda x: x[1], reverse=True)

            # Afficher les 5 meilleurs nettoyeurs
            print(f"Top 5 des recommandations pour le type de nettoyage '{type_nettoyage_choisi}' \n, le type choisi '{type_choisi}' et la ville '{ville_choisie}':")
            for i, (id_nett, score) in enumerate(sorted_predictions[:5], 1):
                print(f"{i}. Nettoyeur ID: {id_nett}, Note Prédite: {score}")

# Attacher la fonction on_button_click à l'événement de clic du bouton
recherche_button.on_click(on_button_click)



directory = 'D:\\XAMPP\\htdocs\\SWILO\\saved\\model\\recommandation'
os.makedirs(directory, exist_ok=True)
model_file_path = os.path.join(directory, 'model.dump')
dump(model_file_path, algo=model)
print(f"Model saved successfully at: {model_file_path}")


